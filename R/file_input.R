#' Get file structure information from a given directory, using the lower directories as groupings.
#'
#' @param path Top directory which contains the lower directories serving as different groups.
#' @param ext File extension of files to be included. Generally this will be either lmd or fcs (case sensitive)
#' @return Matrix containing filepath, group, label (regex currently hardcoded for specific naming schemata)
#' @examples
#' get_dir('/data/flowData', 'FCS')
#' get_dir('../data/fcs', 'lmd')
get_dir <- function(path, ext) {
	l = lapply(list.dirs(path, full.names=FALSE, recursive=FALSE), function(i) {
		filelist = list.files(file.path(path, i), pattern=ext, full.names=FALSE)
		f = sapply(filelist, function(x) {
				   r = regexec('^([KMPB\\d-]+) CLL 9F (\\d+).*.LMD$', x, perl=TRUE)
				   if ('-1' %in% r)
				   	   return(c(NA, NA, NA, NA))
				   m = regmatches(x, r)
				   return(c(file.path(path, i, x), i, m[[1]][[2]], strtoi(m[[1]][[3]])))
  		})
  		f = t(f)
  		f = f[!is.na(f[,1]),]
  		flowCore::colnames(f) = c('filepath', 'group', 'label', 'set')
  		return(f)
  		})
  	files = do.call(rbind, l)
  	return(files)
}

read_file <- function(file_row) {
	f = read.FCS(as.character(file_row[['filepath']]), dataset=1)
	# use simplified markernames, this might be an inappropriate simplification
	m = strsplit(markernames(f), '-')
	newn = sapply(m, function(x) { x[[1]] } )
	flowCore::colnames(f) = newn

	return (c(file_row, fcs=f))
}

#' Load fcs files into a file matrix
#'
#' @param file_info Matrix or Vector containing filename, group, id and set information as generated by get_dir().
#' @param threads Number of cpu threads used in file reading.
#' @param simple_marker_names Use antibody name as marker name.
#' @return File matrix or vector with loaded fcs files.
#' @examples
#' file_matrix = get_dir('/data', 'fcs')
#' read_files(file_matrix)
read_files <- function(file_info, threads=1, simple_marker_names=TRUE) {
	if (is.vector(file_info)) {
		return(read_file(x))
	}
	if (threads > 1) {
		apply_fun = function(x, y) {
			return(parallel::mclapply(x, y, mc.cores=threads))
		}
	} else {
		apply_fun = function(x, y) {
			return(lapply(x, y))
		}
	}
	fcs_list = apply_fun(file_info[,'filepath'], function(x) {
		f = flowCore::read.FCS(as.character(x), dataset=1)
		m = flowCore::markernames(f)
		if (simple_marker_names) {
			m = strsplit(m, '-')
			m = sapply(m, function(x) { x[[1]] } )
		}
		flowCore::colnames(f) = m
		return(f)
	})
	return (cbind(file_info, fcs=fcs_list))
}

#' Remove groups in file matrix with fewer entries than the threshold.
#'
#' @param fcs_info File matrix as generated by get_dir().
#' @param minsize Threshold group size. Groups with fewer entries will be removed from the returned matrix.
#' @return File matrix without groups below threshold.
#' @examples
#' file_info = get_dir('../data', 'fcs')
#' file_info = remove_small_cohorts(file_info, 20)
remove_small_cohorts <- function (fcs_info, minsize=50) {
	## downsampling for flowsom to bite sized chunks
	# set a minimum size to exclude very small cohorts first
	chosen_groups = c()
	file_groups = unique(fcs_info[,'group'])
	for (g in file_groups) {
		groupsize = table(fcs_info[,'group'] == g)['TRUE']
		if (groupsize > minsize) {
			chosen_groups = c(chosen_groups, g)
		} else {
			print(sprintf("Excluding group %s from files, because size %d smaller than threshold %d", g, groupsize, minsize))
			fcs_info = fcs_info[fcs_info[,'group'] != g,]
		}
	}
	return(fcs_info)
}

#' Determine marker names available in all flow data.
#'
#' @param fcs_info File matrix with loaded flowFrames.
#' @param threshold Minimal ratio of the availiability of one marker to all flowframes to be included.
#' @return Vector with marker names available in a larger than threshold ratio of flowframes.
#' @examples
#' fcs_data = load_fcs(file_info, threads=8)
#' majority_markers(fcs_data, threshold=0.8)
majority_markers <- function(fcs_info, threshold=0.95) {
	selected = marker_occurrences(fcs_info) / nrow(fcs_info)
	return(names(selected)[selected > threshold])
}

modify_selection_row <- function(fcs_row, selection) {
	ff = fcs_row['fcs'][[1]]
	ffn = colnames(ff)
	if (!any(is.na(match(selection, ffn)))) {
	 	fcs_row['fcs'] = list(ff[,selection])
	} else {
		fcs_row['fcs'] = NA
	}
	return(fcs_row)
}

#' Reduce flowframes to specified set of marker channels.
#'
#' @param fcs_info File matrix containing loaded flowframes.
#' @param markers Vector of marker names, which will be used for selection.
#' @return Flowframe with filtered flowframes. Flowframes not having all specified markers will be replaced with NA.
filter_flowFrame_markers <- function(fcs_info, markers) {
	if (is.vector(fcs_info)) {
		return(modify_selection_row(fcs_info, markers))
	}
	for (i in 1:nrow(fcs_info)) {
		ff = fcs_info[i,'fcs'][[1]]
	 	ffn = flowCore::colnames(ff)
	 	if (!any(is.na(match(markers, ffn)))) {
	 		fcs_info[i,'fcs'] = list(ff[, markers])
	 	} else {
	 		fcs_info[i,'fcs'] = NA
	 	}
	}
	prev_len = nrow(fcs_info)
	fcs_info = fcs_info[!is.na(fcs_info[,'fcs']),]
	print(sprintf("Removed %d entries because of insuffient marker channels.", prev_len - nrow(fcs_info)))
	return(fcs_info)
}

#' Remove rare flowframe channels and exclude flowframes without common channels.
#'
#' @param fcs_info File matrix with loaded flowframes.
#' @param threshold Minimum ratio for marker to be common.
#' @return File matrix with removed channels.
filter_flowFrame_majority <- function(fcs_info, threshold) {
	selection = majority_markers(fcs_info, threshold)
	occur_hist = marker_occurrences(fcs_info)
	occur_hist = occur_hist / nrow(fcs_info)
	print("Marker occurrences:\n")
	print(occur_hist)
	return(filter_flowFrame_markers(fcs_info, selection))
}

#' Get distribution of marker channels across whole dataset.
#'
#' @param fcs_info File matrix as loaded by get_dir().
#' @return Table with occurrences of marker channels in histogram data.
marker_occurrences <- function(fcs_info) {
	colmatrix = lapply(fcs_info[,'fcs'], flowCore::colnames)
	colen = max(unlist(lapply(colmatrix, length)))
	colmatrix = sapply(colmatrix, function(x) { length(x) = colen; x})

	tab = table(colmatrix)
	return(tab)
}

#' Select one set in file matrix
#'
#' @param file_info File Matrix as loaded by get_dir.
#' @param set Specifies set which will be returned.
#' @return File matrix containing specified set.
select_set <- function(file_info, set) {
	if (is.vector(set) | is.list(set)) {
		return(file_info[file_info[,'set'] %in% set,])
	}
	return(file_info[file_info[,'set'] == set,])
}

#' Generate file matrix from directory
#'
#' A file matrix contains information about each file included in the structure
#' such as group identity, set (used for different experiment tubes for the
#' flow cytometry information). This structure serves as the basis for later
#' clustering and dimension reduction steps.
#'
#' @section File Matrix description:
#' filepath - Name of the file concatenated with the provided path
#' group - Group as specified by the subfolder name
#' set - Additional descriptor identifying multiple files per label. (denotes tube)
#' label - ID label from the filename
#' fcs - flowFrame data from the corresponding file
#'
#' @inheritParams get_dir
#' @inheritParams read_files
#' @inheritParams select_set
#' @inheritParams filter_flowFrame_markers
#' @inheritParams remove_small_cohorts
#' @return File matrix with loaded and filtered datasets.
#' @export
process_dir <- function(path, ext='LMD', set=1, threshold=0.90, group_size=50, threads=1, simple_marker_names=FALSE) {
	file_info = get_dir(path, ext)
	file_info = select_set(file_info, set=set)
	file_info = read_files(file_info, threads=threads, simple_marker_names=simple_marker_names)
	file_info = filter_flowFrame_majority(file_info, threshold)
	file_info = remove_small_cohorts(file_info, group_size)
	return(file_info)
}
