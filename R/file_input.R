#' Get file structure information from a given directory, using the lower directories as groupings.
#'
#' @param path Top directory which contains the lower directories serving as different groups.
#' @param ext File extension of files to be included. Generally this will be either lmd or fcs (case sensitive)
#' @param cluster Optional cluster for parallel processing.
#' @return Matrix containing filepath, group, label (regex currently hardcoded for specific naming schemata)
#' @examples
#' get_dir('/data/flowData', 'FCS')
#' get_dir('../data/fcs', 'lmd')
#' files = get_dir(testdir, 'LMD', cluster)
#' files = get_dir(testdir, 'LMD')
#' @export
get_dir <- function(path, ext, cluster) {
	if (missing(cluster)) {
		lfunc = lapply
	} else {
		lfunc = function(x, y) { parallel::parLapply(cluster, x, y) }
	}
	filelist = list.files(path, pattern=ext, full.names=TRUE,recursive=TRUE)
	f = lfunc(filelist, function(x) {
			   r = regexec('^.*/(\\w+)/(\\d+-\\d+)-(\\w+) CLL 9F (\\d+).*.LMD$', x, perl=TRUE)
			   if ('-1' %in% r) {
			   	   return(NA)
			   }
			   m = regmatches(x, r)
			   filepath = x
			   group = m[[1]][[2]]
			   label = m[[1]][[3]]
			   material = m[[1]][[4]]
			   tube_set = as.numeric(m[[1]][[5]])
			   fe = new('flowEntry',
			   			filepath=filepath,group=group,label=label,material=material,tube_set=tube_set)
			   return(fe)
	})
	f = f[!is.na(f)]
	return(f)
}

read_file <- function(flow_entry, simple_marker_names=FALSE,dataset=1) {
	flow_entry@fcs = flowCore::read.FCS(flow_entry@filepath, dataset=dataset)
	# use simplified markernames, this might be an inappropriate simplification
	m = flowCore::markernames(flow_entry@fcs)
	curnames = flowCore::colnames(flow_entry@fcs)
	if (length(m) > length(curnames)) {
		stop(sprintf("Length of %d markernames does not match length %d of current names", curnames, m))
	}
	for (s in 1:length(m)) {
		curnames[s] = m[[s]]
	}

	if (simple_marker_names) {
		m = strsplit(m, '-')
		m = sapply(m, function(x) { x[[1]] } )
	}
	flowCore::colnames(flow_entry@fcs) = curnames

	return (flow_entry)
}

#' Load fcs files into a file matrix
#'
#' @param file_info Matrix or Vector containing filename, group, id and set information as generated by get_dir().
#' @param cluster Define cluster for concurrent operations.
#' @param simple_marker_names Use antibody name as marker name.
#' @param Dataset used in fcs files with multiple datasets.
#' @return File entries list or file entry object with loaded fcs files.
#' @examples
#' file_entries = get_dir('/data', 'fcs')
#' read_files(file_matrix)
read_files <- function(file_entries, cluster, simple_marker_names=FALSE, dataset=1) {
	if (missing(cluster)) {
		apply_fun = function(x, y) {
			return(parallel::parLapply(cluster, x, y))
		}
	} else {
		apply_fun = function(x, y) {
			return(lapply(x, y))
		}
	}
	if (!is.list(file_entries)) {
		return(read_file(file_entries, simple_marker_names))
	}
	file_entries = apply_fun(file_entries, function(x) {
		read_file(x, simple_marker_names=simple_marker_names, dataset=1)
	})
	return (file_entries)
}

#' Remove groups in file matrix with fewer entries than the threshold.
#'
#' @param fcs_info File matrix as generated by get_dir().
#' @param minsize Threshold group size. Groups with fewer entries will be removed from the returned matrix.
#' @return File matrix without groups below threshold.
#' @examples
#' file_info = get_dir('../data', 'fcs')
#' file_info = remove_small_cohorts(file_info, 20)
#' t = remove_small_cohorts(files, 1000)
remove_small_cohorts <- function (file_entries, minsize) {
	## downsampling for flowsom to bite sized chunks
	# set a minimum size to exclude very small cohorts first
	if (missing(minsize)) {
		return(file_entries)
	}
	chosen_groups = c()
	group_names = sapply(file_entries, function(x) { x@group })
	group_sizes = table(group_names)
	chosen_groups = names(group_sizes[group_sizes >= minsize])
	file_entries = file_entries[group_names %in% chosen_groups]
	return(file_entries)
}

#' Filter list of flowEntries on arbitrary slots
#'
#' @param file_entries List of flow entries
#' @param ... named argument corresponding to a fcs slot
#' @return Filtered list of flowEntries
#' @examples
#' filtered = filter_list(files, tube_set=1, group='normal')
#' @export
filter_list <- function(file_entries, ...) {
	params = list(...)
	filter_params = params[names(params) %in% names(getSlots('flowEntry'))]
	for (filter_slot in names(filter_params)) {
		filter_val = filter_params[[filter_slot]]
		file_entries = lapply(file_entries, function(entry) {
		  if (as.character(slot(entry,filter_slot)) == as.character(filter_val))
		  	  return(entry)
		  else
		  	  return(NA)
		})
		file_entries = file_entries[!is.na(file_entries)]
	}
	return(file_entries)
}

#' Reduce flowframe to specified set of marker channels.
#'
#' @param fcs_entry File matrix containing loaded flowframes.
#' @param selection Vector of marker names, which will be used for selection.
#' @return Flowframe with filtered flowframes. Flowframes not having all specified markers will be replaced with NA.
fcs_select_markers <- function(fcs_entry, selection) {
	ffn = flowCore::colnames(fcs_entry@fcs)
	if (!any(is.na(match(selection, ffn)))) {
	 	fcs_entry@fcs = fcs_entry@fcs[,selection]
	 	return(fcs_entry)
	} else {
		return(NA)
	}
}

#' Exclude flowframes without common channels.
#'
#' @param fcs_info File matrix with loaded flowframes.
#' @param threshold Minimum ratio for marker to be common.
#' @return File matrix with removed channels.
#' @examples
#' t = filter_flowFrame_majority(files[1:10], 0.8)
#' t = filter_flowFrame_majority(files, 0.8, cluster)
#' @export
filter_flowFrame_majority <- function(flow_entries, threshold, cluster) {
	marker_matrix = marker_occurrences(flow_entries, cluster)
	marker_sums = colSums(marker_matrix)
	selected_marker = names(marker_sums)[marker_sums / nrow(marker_matrix) >= threshold]
	selected_matrix = marker_matrix[,selected_marker]
	selected_files = flow_entries[rowSums(selected_matrix) == length(selected_marker)]
	return(list(entries=selected_files,markers=selected_marker))
}

#' Get distribution of marker channels across whole dataset.
#'
#' @param flow_entries Flow entry list, FCS do not have to be loaded
#' @return Table with occurrences of marker channels as 1/0 matrix.
#' @examples
#' t = marker_occurrences(files, cluster)
#' t = marker_occurrences(files[1:10])
marker_occurrences <- function(flow_entries, cluster) {
	if (missing(cluster))
		lfunc = lapply
	else
		lfunc = function(x,y) { parallel::parLapply(cluster,x,y) }

	colmatrix = lfunc(flow_entries, function(x) {
						   loaded = read_file(x)
						   fnames = flowCore::colnames(loaded@fcs)
						   fnamevec = rep(1, length(fnames))
						   names(fnamevec) = fnames
						   return(t(fnamevec))
	})
	colmatrix = plyr::rbind.fill.matrix(colmatrix)
	colmatrix[is.na(colmatrix)] = 0
	return(colmatrix)
}

#' Remove duplicates with same filename from file matrix.
#'
#' @param File matrix as output by get_dir()
#' @return File matrix with duplicates removed. All occurrences are removed.
#' @examples
#' t = remove_duplicates(files)
remove_duplicates <- function(fcs_entries) {
	# remove duplicates until we have a better idea
	filenames = sapply(fcs_entries, function(entry) {
							basename(entry@filepath)
	})
	file_freq = table(filenames)
	file_freq = file_freq[file_freq > 1 ]
	print(paste("Removed duplicates", names(file_freq)))
	duplicate = filenames %in% names(file_freq)
	return(fcs_entries[!duplicate])
}

#' Read and preprocess file structure
#'
#' Convenient wapper to extract a single set without duplicates from directory file structure.
#'
#' @inheritParams get_dir
#' @param set Chosen tube set for the files.
#' @return File matrix with specified set and no duplicates.
#' @export
create_file_info <- function(path, ext, set) {
	file_info = get_dir(path, ext)
	if (is.null(file_info)) {
		print(sprintf("No files found in given directory %s", getwd()))
		return(file_info)
	}
	file_info = filter_list(file_info, tube_set=set)
	file_info = remove_duplicates(file_info)
	return(file_info)
}

#' Remove marginal cells
#'
#' Removes all events with at least one border value.
#' The border is defined via the parameter range or as the min/max of the dataset.
#'
#' @param flow_entry Flow data with loaded fcs slot.
#' @return Flow entry with marginal events removed.
#' @examples
#' remove_marginal(testflow)
remove_marginal <- function(flow_entry) {
	cols = range(flow_entry@fcs)
	ex = flowCore::exprs(flow_entry@fcs)
	sel = sapply(1:ncol(cols), function(i) {
		ex[,i] > max(cols[1,i],min(ex[,i])) &
			ex[,i] < min(cols[2,i],max(ex[,i]))
	})
	ex = ex[rowSums(sel) == ncol(sel),]
	flowCore::exprs(flow_entry@fcs) = ex
	return(flow_entry)
}

# not implemented because it requires forward scatter area and height
# remove_doublets <- function(flow_entry) {
# 
# }

#' Remove debris

#' Load and filter single file info entry
#'
#' @param file_row File info row from a file matrix.
#' @param selection Marker names selected from flowframe.
#' @param trans String name for transformation function.
#' @return File row or NULL if marker name not in flowframe.
#' @export
#' @examples
#' t = process_single(files[[1]],selection)
process_single <- function(file_entry, selection, simple_marker_names=FALSE, trans='logicle') {
	file_entry = read_file(file_entry, simple_marker_names)

	if (!isS4(file_entry)) {
		return (NULL)
	}
	file_entry = fcs_select_markers(file_entry, selection)
	if (!isS4(file_entry)) {
		cat(paste("Skipping", file_entry@filepath, "because NA encountered.\n"))
		return(NULL)
	}
	file_entry = remove_marginal(file_entry)
	sel_fun = function(x) { !grepl("LIN", x) }
	if (trans == 'logicle') {
		trans_fun = flowCore::logicleTransform()
	} else {
		trans_fun = flowCore::logTransform(transformationId="log10-transformation", logbase=10, r=1, d=1)
	}
	file_entry@fcs = transform_ff(file_entry@fcs, sel_fun, trans_fun)
	return(file_entry)
}

#' Transform flowcytometric marker channels.
#'
#' Apply a transformation function to the channels specified by the selection function.
#'
#' @param ff Flowframe
#' @param sel_fun Selection function to determine transform application, which returns for an input name either TRUE or FALSE
#' @param trans_fun Transformation function, which will be applied.
#' @return File Matrix with transformed flow frames.
transform_ff <- function(ff, sel_fun, trans_fun) {
	markernames = flowCore::colnames(ff)
	trans_markers = markernames[sel_fun(markernames)]
	transform_list = flowCore::transformList(trans_markers, trans_fun)
	ff = flowCore::transform(ff, transform_list)
	return(ff)
}

#' S4 class representing a flowframe with additional metadata
#'
#' @slot filepath Path to fcs file.
#' @slot group Group of single case. Most often corresponding to the disease label.
#' @slot label Unique identifier matching a single case.
#' @slot material Sample material used in analysis.
#' @slot tube_set Multiple tubes can be used to capture a larger number of channels per sample.
#' @slot fcs Slot to load fcs file.
#' @importClassesFrom flowCore flowFrame
FlowEntry <- setClass('FlowEntry',
		 representation(
		 	filepath='character'
		 	,group='character'
		 	,label='character'
		 	,material='character'
		 	,tube_set='numeric'
		 	,fcs='flowFrame'
		 	)
		 )
