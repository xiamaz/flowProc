#' Get file structure information from a given directory, using the lower directories as groupings.
#'
#' @param path Top directory which contains the lower directories serving as different groups.
#' @param ext File extension of files to be included. Generally this will be either lmd or fcs (case sensitive)
#' @param cluster Optional cluster for parallel processing.
#' @return Matrix containing filepath, group, label (regex currently hardcoded for specific naming schemata)
#' @examples
#' GetDir('/data/flowData', 'FCS')
#' GetDir('../data/fcs', 'lmd')
#' files = GetDir(testdir, 'LMD', cluster)
#' files = GetDir(testdir, 'LMD')
#' @export
GetDir <- function(path, ext, cluster) {
  if (missing(cluster)) {
    lfunc <- lapply
  } else {
    lfunc <- function(x, y) { parallel::parLapply(cluster, x, y) }
  }
  filelist <- list.files(path, pattern = ext, full.names = TRUE, recursive = TRUE)
  f <- lfunc(filelist, function(x) {
         r <- regexec("^.*/(\\w+)/(\\d+-\\d+)-(\\w+) CLL 9F (\\d+).*.LMD$", x, perl = TRUE)
         if ("-1" %in% r) {
             return(NA)
         }
         m <- regmatches(x, r)
         filepath <- x
         group <- m[[1]][[2]]
         label <- m[[1]][[3]]
         material <- m[[1]][[4]]
         tube_set <- as.numeric(m[[1]][[5]])
         fe <- new("FlowEntry",
              filepath = filepath, group = group, label = label, material = material, tube_set = tube_set)
         return(fe)
  })
  f <- f[!is.na(f)]
  return(f)
}

#' Load single fcs file into a file matrix
#'
#' @export
read_file <- function(flow_entry, simple_marker_names=FALSE,dataset=1) {
  flow_entry@fcs = flowCore::read.FCS(flow_entry@filepath, dataset=dataset)
  # use simplified markernames, this might be an inappropriate simplification
  m = flowCore::markernames(flow_entry@fcs)
  curnames = flowCore::colnames(flow_entry@fcs)
  if (length(m) > length(curnames)) {
    stop(sprintf("Length of %d markernames does not match length %d of current names", curnames, m))
  }
  for (s in 1:length(m)) {
    curnames[s] = m[[s]]
  }

  if (simple_marker_names) {
    m = strsplit(m, '-')
    m = sapply(m, function(x) { x[[1]] } )
  }
  flowCore::colnames(flow_entry@fcs) = curnames

  return (flow_entry)
}

#' Load fcs files into a file matrix
#'
#' @param file_info Matrix or Vector containing filename, group, id and set
#' information as generated by GetDir().
#' @param cluster Define cluster for concurrent operations.
#' @param simple_marker_names Use antibody name as marker name.
#' @param Dataset used in fcs files with multiple datasets.
#' @return File entries list or file entry object with loaded fcs files.
#' @examples
#' file_entries = GetDir('/data', 'fcs')
#' read_files(file_matrix)
#' @export
read_files <- function(file_entries, cluster, simple_marker_names=FALSE, dataset=1) {
  if (missing(cluster)) {
    apply_fun = function(x, y) {
      return(parallel::parLapply(cluster, x, y))
    }
  } else {
    apply_fun = function(x, y) {
      return(lapply(x, y))
    }
  }
  if (!is.list(file_entries)) {
    return(read_file(file_entries, simple_marker_names))
  }
  file_entries = apply_fun(file_entries, function(x) {
    read_file(x, simple_marker_names=simple_marker_names, dataset=1)
  })
  return (file_entries)
}

#' Remove groups in file matrix with fewer entries than the threshold.
#'
#' @param fcs_info File matrix as generated by GetDir().
#' @param minsize Threshold group size. Groups with fewer entries will be removed from the returned matrix.
#' @return File matrix without groups below threshold.
#' @examples
#' file_info = GetDir('../data', 'fcs')
#' file_info = remove_small_cohorts(file_info, 20)
#' t = remove_small_cohorts(files, 1000)
remove_small_cohorts <- function (file_entries, minsize) {
  ## downsampling for flowsom to bite sized chunks
  # set a minimum size to exclude very small cohorts first
  if (missing(minsize)) {
    return(file_entries)
  }
  chosen_groups = c()
  group_names = sapply(file_entries, function(x) { x@group })
  group_sizes = table(group_names)
  chosen_groups = names(group_sizes[group_sizes >= minsize])
  file_entries = file_entries[group_names %in% chosen_groups]
  return(file_entries)
}

#' Group list by slow value
#' @param upsampled.list List of entries.
#' @param group.on Slot to group entries on if using the default indexer and
#' comparator.
#' @param acc Alternative function to access the information for grouping.
#' @examples
#' GroupBy(all.files, 'label')
#' GroupBy(all.files, 'label', num.threads=12)
#' @export
GroupBy <- function(upsampled.list, group.on, acc, num.threads = 1) {
  if (missing(acc)) {
    acc <- slot
  }
  group.names <- unique(sapply(upsampled.list, function(x) {
                                 acc(x, group.on)
  }))
  # fork into multiple threads if desired
  if (num.threads > 1) {
    lapply.func <- function(x, fun) {
      cl <- parallel::makeCluster(num.threads, type = "FORK")
      resp <- parallel::parLapply(cl = cl, x, fun)
      parallel::stopCluster(cl)
      return(resp)
    }
  } else {
    lapply.func <- lapply
  }
  # group all files into list of lists
  groups <- lapply.func(group.names,
                   function(x) {
                     f <- list(x)
                     names(f) <- group.on
                     upsampled.list[FilterEntries(upsampled.list, f, acc = acc)]
                   })
  names(groups) <- group.names
  return(groups)
}

#' Filter list of flowEntries on arbitrary slots
#'
#' Filter using argument names instead of filters list
#' @param file.entries List of flow entries
#' @param ... named argument corresponding to a fcs slot
#' @return Filtered list of flowEntries
#' @examples
#' filtered = FilterList(files, tube_set=1, group='normal')
#' @export
FilterList <- function(file.entries, ...) {
  params <- list(...)
  return(file.entries[FilterEntries(file.entries, params)])
}

#' Return boolean vector for a list based on filter
#'
#' @param file.list List of S4 objects implementing the names in the filter.
#' @param filters List of named vectors.
#' @param acc Optional parameter to override the function used to access the
#' compared value.
#' @return boolean vector used for subsetting the list.
#' @examples
#' all.files[FilterOnAttr(all.files, list(group='CLL'))]
#' @export
FilterEntries <- function(entry.list, filters, acc) {
  if (missing(acc)) {
    acc <- slot
  }
  sapply(entry.list, function(x) {
           FilterEntry(x, filters, acc = acc)
                             })
}

#' Return bool for entry depending on whether it matches filter
#'
#' @param entry Entry type S4 class.
#' @param filters List of vectors containing acceptable values.
#' @param acc Function to access the value being compared.
#' @return Boolean whether filter is fulfilled.
FilterEntry <- function(entry, filters, acc) {
  # check if all criteria in filters, a named list of values is fulfilled
  for (slot.name in names(filters)) {
    if (!acc(entry, slot.name) %in% filters[[slot.name]]) {
      return(F)
    }
  }
  return(T)
}


#' Reduce flowframe to specified set of marker channels.
#'
#' @param fcs_entry File matrix containing loaded flowframes.
#' @param selection Vector of marker names, which will be used for selection.
#' @return Flowframe with filtered flowframes. Flowframes not having all specified markers will be replaced with NA.
fcs_select_markers <- function(fcs_entry, selection) {
  ffn = flowCore::colnames(fcs_entry@fcs)
  if (!any(is.na(match(selection, ffn)))) {
    fcs_entry@fcs = fcs_entry@fcs[,selection]
    return(fcs_entry)
  } else {
    return(NA)
  }
}

#' Exclude flowframes without common channels.
#'
#' @param fcs_info File matrix with loaded flowframes.
#' @param threshold Minimum ratio for marker to be common.
#' @return File matrix with removed channels.
#' @examples
#' t = filter_flowFrame_majority(files[1:10], 0.8)
#' t = filter_flowFrame_majority(files, 0.8, cluster)
#' @export
filter_flowFrame_majority <- function(flow_entries, threshold, cluster) {
  if (missing(cluster)) {
    lfunc <- lapply
  } else {
    lfunc <- function(x, y) { parallel::parLapply(cluster, x, y) }
  }
  loaded.entries <- lfunc(flow_entries, function(x) { read_file(x) })

  return(FilterChannelMajority(loaded.entries, threshold = threshold))
}

#' Return flowframes with common channels and selected channels.
#'
#' @param flow.entries File matrix with loaded flowframes.
#' @param threshold Minimum ratio for marker to be common.
#' @return List with filtered list and the names of the selected channels.
#' @export
FilterChannelMajority <- function(flow.entries, threshold = 0.9) {
  marker.matrix <- MarkerOccurences(flow.entries)
  marker.sums <- colSums(marker.matrix)
  # get marker names over threshold
  selected.markers <- names(marker.sums)[marker.sums / nrow(marker.matrix) >= threshold]
  # select entries with all markers present
  selected.matrix <- marker.matrix[, selected.markers]
  selected.files <- flow.entries[rowSums(selected.matrix) == length(selected.markers)]
  selected.files <- lapply(selected.files, function(entry) {
                             entry@fcs <- entry@fcs[, selected.markers]
                             return(entry)
                             })
  return(list(entries = selected.files, markers = selected.markers))
}

#' Get distribution of marker channels across whole dataset.
#'
#' @param flow_entries Flow entry list with loaded fcs files.
#' @return Table with occurrences of marker channels as 1/0 matrix.
#' @examples
#' t = marker_occurrences(files, cluster)
#' t = marker_occurrences(files[1:10])
#' @export
MarkerOccurences <- function(flow.entries) {
  # save colnames as vector of ones
  colmatrix <- lapply(flow.entries, function(x) {
               fnames <- flowCore::colnames(x@fcs)
               fnamevec <- rep(1, length(fnames))
               names(fnamevec) <- fnames
               return(t(fnamevec))
  })
  colmatrix <- plyr::rbind.fill.matrix(colmatrix)
  colmatrix[is.na(colmatrix)] <- 0
  return(colmatrix)
}

#' Remove duplicates with same filename from file matrix.
#'
#' @param File matrix as output by GetDir()
#' @return File matrix with duplicates removed. All occurrences are removed.
#' @examples
#' t = remove_duplicates(files)
#' @export
remove_duplicates <- function(fcs_entries) {
  # remove duplicates until we have a better idea
  filenames = sapply(fcs_entries, function(entry) {
              basename(entry@filepath)
  })
  file_freq = table(filenames)
  file_freq = file_freq[file_freq > 1 ]
  print(paste("Removed duplicates", names(file_freq)))
  duplicate = filenames %in% names(file_freq)
  return(fcs_entries[!duplicate])
}

#' Read and preprocess file structure
#'
#' Convenient wapper to extract a single set without duplicates from directory file structure.
#'
#' @inheritParams GetDir
#' @param set Chosen tube set for the files.
#' @return File matrix with specified set and no duplicates.
#' @export
create_file_info <- function(path, ext, set, cluster) {
  file_info <- GetDir(path, ext, cluster=cluster)
  if (is.null(file_info)) {
    print(sprintf("No files found in given directory %s", getwd()))
    return(file_info)
  }
  file_info <- FilterList(file_info, tube_set=set)
  file_info <- remove_duplicates(file_info)
  return(file_info)
}

#' Remove marginal cells
#'
#' Removes all events with at least one border value.
#' The border is defined via the parameter range or as the min/max of the dataset.
#'
#' @param flow_entry Flow data with loaded fcs slot.
#' @param lower Boolean to enable lower boundary filtering.
#' @param upper Boolean to enable upper boundary filtering.
#' @return Flow entry with marginal events removed.
#' @examples
#' remove_marginal(testflow)
#' @export
remove_marginal <- function(flow_entry, lower = TRUE, upper = TRUE) {
  cols <- range(flow_entry@fcs)
  ex <- flowCore::exprs(flow_entry@fcs)
  sel <- sapply(1:ncol(cols), function(i) {
    if(lower & upper) {
      ex[,i] > max(cols[1,i],min(ex[,i])) &
      ex[,i] < min(cols[2,i],max(ex[,i]))
    } else if (lower) {
      ex[,i] > max(cols[1,i],min(ex[,i]))
    } else if (upper) {
      ex[,i] < min(cols[2,i],max(ex[,i]))
    } else {
      ex[,i] & TRUE
    }
  })
  if (nrow(ex) <= 1) {
    print(ex)
    flow_entry = NA
  } else {
    ex = ex[rowSums(sel) == ncol(sel),]
    if (!is.matrix(ex))  {
      return(NA)
    }
    flowCore::exprs(flow_entry@fcs) = ex
  }
  return(flow_entry)
}

# not implemented because it requires forward scatter area and height
# remove_doublets <- function(flow_entry) {
#
# }

#' Remove debris

#' Load and filter single file info entry
#'
#' @param file_row File info row from a file matrix.
#' @param selection Marker names selected from flowframe.
#' @param trans String name for transformation function.
#' @param remove_margins Boolean for removal of events with 0 or maximum values.
#' @return File row or NULL if marker name not in flowframe.
#' @export
#' @examples
#' t = process_single(files[[1]],selection)
process_single <- function(file_entry, selection, simple_marker_names=FALSE, trans='logicle',remove_margins=TRUE,upper=TRUE,lower=TRUE) {
  file_entry = read_file(file_entry, simple_marker_names)

  if (!isS4(file_entry)) {
    return (NA)
  }
  if (!missing(selection)) {
    file_entry = fcs_select_markers(file_entry, selection)
    if (!isS4(file_entry)) {
      return(NA)
    }
  }
  if (remove_margins) {
    file_entry = remove_marginal(file_entry,upper=upper,lower=lower)
    if (!isS4(file_entry)) {
      return(NA)
    }
  }
  sel_fun = function(x) { !grepl("LIN", x) }
  if (trans == 'logicle') {
    trans_fun = flowCore::logicleTransform()
  } else {
    trans_fun = flowCore::logTransform(transformationId="log10-transformation", logbase=10, r=1, d=1)
  }
  file_entry@fcs = transform_ff(file_entry@fcs, sel_fun, trans_fun)
  return(file_entry)
}

#' Transform flowcytometric marker channels.
#'
#' Apply a transformation function to the channels specified by the selection function.
#'
#' @param ff Flowframe
#' @param sel_fun Selection function to determine transform application, which returns for an input name either TRUE or FALSE
#' @param trans_fun Transformation function, which will be applied.
#' @return File Matrix with transformed flow frames.
transform_ff <- function(ff, sel_fun, trans_fun) {
  markernames <- flowCore::colnames(ff)
  trans_markers <- markernames[sel_fun(markernames)]
  transform_list <- flowCore::transformList(trans_markers, trans_fun)
  ff <- flowCore::transform(ff, transform_list)
  return(ff)
}

#' S4 class representing a flowframe with additional metadata
#'
#' @slot filepath Path to fcs file.
#' @slot group Group of single case. Most often corresponding to the disease label.
#' @slot label Unique identifier matching a single case.
#' @slot material Sample material used in analysis.
#' @slot tube_set Multiple tubes can be used to capture a larger number of channels per sample.
#' @slot fcs Slot to load fcs file.
#' @importClassesFrom flowCore flowFrame
FlowEntry <- setClass("FlowEntry",
     representation(
      filepath = "character",
      group = "character",
      label = "character",
      material = "character",
      tube_set = "numeric",
      fcs = "flowFrame"
      )
     )
