#' Get file structure information from a given directory, using the lower directories as groupings.
#'
#' @param path Top directory which contains the lower directories serving as different groups.
#' @param ext File extension of files to be included. Generally this will be either lmd or fcs (case sensitive)
#' @return Matrix containing filepath, group, label (regex currently hardcoded for specific naming schemata)
#' @examples
#' get_dir('/data/flowData', 'FCS')
#' get_dir('../data/fcs', 'lmd')
#' @export
get_dir <- function(path, ext) {
	l = lapply(list.dirs(path, full.names=FALSE, recursive=FALSE), function(i) {
		filelist = list.files(file.path(path, i), pattern=ext, full.names=FALSE)
		f = sapply(filelist, function(x) {
				   r = regexec('^(\\d+-\\d+)-(\\w+) CLL 9F (\\d+).*.LMD$', x, perl=TRUE)
				   if ('-1' %in% r)
				   	   return(c(NA, NA, NA, NA, NA))
				   m = regmatches(x, r)
				   return(c(file.path(path, i, x), i, m[[1]][[2]], m[[1]][[3]], strtoi(m[[1]][[4]])))
  		})
  		f = t(f)
  		f = f[!is.na(f[,1]),]
  		colnames(f) = c('filepath', 'group', 'label', 'material', 'set')
  		return(f)
  		})
  	files = do.call(rbind, l)
  	return(files)
}

read_file <- function(file_row, simple_marker_names) {
	f = flowCore::read.FCS(as.character(file_row[['filepath']]), dataset=1)
	# use simplified markernames, this might be an inappropriate simplification
	m = flowCore::markernames(f)
	if (simple_marker_names) {
		m = strsplit(m, '-')
		m = sapply(m, function(x) { x[[1]] } )
	}
	flowCore::colnames(f) = m

	return (c(file_row, fcs=f))
}

#' Load fcs files into a file matrix
#'
#' @param file_info Matrix or Vector containing filename, group, id and set information as generated by get_dir().
#' @param threads Number of cpu threads used in file reading.
#' @param simple_marker_names Use antibody name as marker name.
#' @return File matrix or vector with loaded fcs files.
#' @examples
#' file_matrix = get_dir('/data', 'fcs')
#' read_files(file_matrix)
read_files <- function(file_info, threads=1, simple_marker_names) {
	if (is.vector(file_info)) {
		return(read_file(x, simple_marker_names))
	}
	if (threads > 1) {
		apply_fun = function(x, y) {
			return(parallel::mclapply(x, y, mc.cores=threads))
		}
	} else {
		apply_fun = function(x, y) {
			return(lapply(x, y))
		}
	}
	fcs_list = apply_fun(file_info[,'filepath'], function(x) {
		f = flowCore::read.FCS(as.character(x), dataset=1)
		m = flowCore::markernames(f)
		if (simple_marker_names) {
			m = strsplit(m, '-')
			m = sapply(m, function(x) { x[[1]] } )
		}
		flowCore::colnames(f) = m
		return(f)
	})
	return (cbind(file_info, fcs=fcs_list))
}

#' Remove groups in file matrix with fewer entries than the threshold.
#'
#' @param fcs_info File matrix as generated by get_dir().
#' @param minsize Threshold group size. Groups with fewer entries will be removed from the returned matrix.
#' @return File matrix without groups below threshold.
#' @examples
#' file_info = get_dir('../data', 'fcs')
#' file_info = remove_small_cohorts(file_info, 20)
remove_small_cohorts <- function (fcs_info, minsize) {
	## downsampling for flowsom to bite sized chunks
	# set a minimum size to exclude very small cohorts first
	if (is.na(minsize)) {
		return(fcs_info)
	}
	chosen_groups = c()
	file_groups = unique(fcs_info[,'group'])
	for (g in file_groups) {
		groupsize = table(fcs_info[,'group'] == g)['TRUE']
		if (groupsize > minsize) {
			chosen_groups = c(chosen_groups, g)
		} else {
			print(sprintf("Excluding group %s from files, because size %d smaller than threshold %d", g, groupsize, minsize))
			fcs_info = fcs_info[fcs_info[,'group'] != g,]
		}
	}
	return(fcs_info)
}

#' Determine marker names available in all flow data.
#'
#' @param fcs_info File matrix with loaded flowFrames.
#' @param threshold Minimal ratio of the availiability of one marker to all flowframes to be included.
#' @return Vector with marker names available in a larger than threshold ratio of flowframes.
#' @examples
#' fcs_data = load_fcs(file_info, threads=8)
#' majority_markers(fcs_data, threshold=0.8)
majority_markers <- function(fcs_info, threshold) {
	selected = marker_occurrences(fcs_info) / nrow(fcs_info)
	return(names(selected)[selected > threshold])
}

modify_selection_row <- function(fcs_row, selection) {
	ff = fcs_row['fcs'][[1]]
	ffn = flowCore::colnames(ff)
	if (!any(is.na(match(selection, ffn)))) {
	 	fcs_row['fcs'] = list(ff[,selection])
	} else {
		fcs_row['fcs'] = NA
	}
	return(fcs_row)
}

#' Reduce flowframes to specified set of marker channels.
#'
#' @param fcs_info File matrix containing loaded flowframes.
#' @param markers Vector of marker names, which will be used for selection.
#' @return Flowframe with filtered flowframes. Flowframes not having all specified markers will be replaced with NA.
filter_flowFrame_markers <- function(fcs_info, markers) {
	if (is.vector(fcs_info)) {
		return(modify_selection_row(fcs_info, markers))
	}
	for (i in 1:nrow(fcs_info)) {
		ff = fcs_info[i,'fcs'][[1]]
	 	ffn = flowCore::colnames(ff)
	 	if (!any(is.na(match(markers, ffn)))) {
	 		fcs_info[i,'fcs'] = list(ff[, markers])
	 	} else {
	 		fcs_info[i,'fcs'] = NA
	 	}
	}
	prev_len = nrow(fcs_info)
	fcs_info = fcs_info[!is.na(fcs_info[,'fcs']),]
	print(sprintf("Removed %d entries because of insuffient marker channels.", prev_len - nrow(fcs_info)))
	return(fcs_info)
}

#' Remove rare flowframe channels and exclude flowframes without common channels.
#'
#' @param fcs_info File matrix with loaded flowframes.
#' @param threshold Minimum ratio for marker to be common.
#' @return File matrix with removed channels.
filter_flowFrame_majority <- function(fcs_info, threshold) {
	selection = majority_markers(fcs_info, threshold)
	occur_hist = marker_occurrences(fcs_info)
	occur_hist = occur_hist / nrow(fcs_info)
	print("Marker occurrences:\n")
	print(occur_hist)
	return(list(file_info=filter_flowFrame_markers(fcs_info, selection), selection=selection))
}

#' Get distribution of marker channels across whole dataset.
#'
#' @param fcs_info File matrix as loaded by get_dir().
#' @return Table with occurrences of marker channels in histogram data.
marker_occurrences <- function(fcs_info) {
	colmatrix = lapply(fcs_info[,'fcs'], flowCore::colnames)
	colen = max(unlist(lapply(colmatrix, length)))
	colmatrix = sapply(colmatrix, function(x) { length(x) = colen; x})

	tab = table(colmatrix)
	return(tab)
}

#' Select one set in file matrix
#'
#' @inheritParams filter_file_info
#' @param set Specifies set which will be returned.
#' @return File matrix containing specified set.
select_set <- function(file_info, set) {
	return(filter_file_info(file_info, set=set))
}

#' Filter file matrix according to parameters
#'
#' @param file_info File Matrix as loaded by get_dir
#' @param ... named parameters matching names in the file matrix.
#' @return Filtered file matrix.
filter_file_info <- function(file_info, ...) {
	kwargs = list(...)
	n = colnames(file_info)
	avail = kwargs[names(kwargs) %in% n]
	for (nfilter in names(avail)) {
		f = avail[[nfilter]]
		if (length(f) == 1){
			file_info = file_info[file_info[,nfilter] == f,]
		} else {
			file_info = file_info[file_info[,nfilter] %in% f,]
		}
	}
	return(file_info)
}

#' Remove duplicates from file matrix.
#'
#' @param File matrix as output by get_dir()
#' @return File matrix with duplicates removed. All occurrences are removed.
remove_duplicates <- function(file_info) {
	# remove duplicates until we have a better idea
	file_freq = table(unlist(rownames(file_info)))
	file_freq = file_freq[file_freq > 1 ]
	if (length(file_freq) > 0) {
		duplicates = names(file_freq)
		for (d in duplicates) {
			print(sprintf("Removed duplicate %s", d))
			g = grep(d, rownames(file_info))
			file_info[g[1], 'filepath'] = NA
			file_info[g[2], 'filepath'] = NA
		}
		file_info = file_info[!is.na(file_info[,'filepath']),]
	}
	return(file_info)
}

limit_size <- function(file_info, group_size) {
	if (is.na(group_size)) {
		return(file_info)
	}
	print(ncol(file_info))
	tf_subset = matrix(ncol=ncol(file_info), nrow=0)
	for (g in unique(file_info[,'group'])) {
		tf_subset = rbind(tf_subset, head(file_info[file_info[,'group'] == g,], n=group_size))
	}
	return(tf_subset)
}

#' Read and preprocess file structure
#'
#' Convinient wapper to extract a single set without duplicates from directory file structure.
#'
#' @inheritParams get_dir
#' @inheritParams select_set
#' @return File matrix with specified set and no duplicates.
#' @export
create_file_info <- function(path, ext, set) {
	file_info = get_dir(path, ext)
	if (is.null(file_info)) {
		print(sprintf("No files found in given directory %s", getwd()))
		return(file_info)
	}
	file_info = select_set(file_info, set=set)
	file_info = remove_duplicates(file_info)
	return(file_info)
}

#' Load and filter single file info entry
#'
#' @param file_row File info row from a file matrix.
#' @param selection Marker names selected from flowframe.
#' @return File row or NULL if marker name not in flowframe.
#' @export
process_single <- function(file_row, selection, simple_marker_names=FALSE) {
	file_row = read_file(file_row, simple_marker_names)
	file_row = modify_selection_row(file_row, selection)
	if (any(is.na(file_row))) {
		cat(paste("Skipping", file_row['filepath'], "because NA encountered.\n"))
		return(NULL)
	}
	sel_fun = function(x) { !grepl("LIN", x) }
	trans_fun = flowCore::logTransform(transformationId="log10-transformation", logbase=10, r=1, d=1)
	file_row['fcs'] = list(transform_ff(file_row[['fcs']], sel_fun, trans_fun))
	return(file_row)
}

#' Generate file matrix from directory
#'
#' A file matrix contains information about each file included in the structure
#' such as group identity, set (used for different experiment tubes for the
#' flow cytometry information). This structure serves as the basis for later
#' clustering and dimension reduction steps.
#'
#' @section File Matrix description:
#' filepath - Name of the file concatenated with the provided path
#' group - Group as specified by the subfolder name
#' set - Additional descriptor identifying multiple files per label. (denotes tube)
#' label - ID label from the filename
#' fcs - flowFrame data from the corresponding file
#'
#' @inheritParams get_dir
#' @inheritParams read_files
#' @inheritParams select_set
#' @inheritParams filter_flowFrame_markers
#' @param group_size Size of returned groups, if defined, each cohort will have this size. Smaller cohorts will be discarded.
#' @return File matrix with loaded and filtered datasets.
#' @export
process_dir <- function(path, ext='LMD', set=1, material=NULL, threshold=0.90, group_size=NA, threads=1, simple_marker_names=FALSE) {
	file_info = create_file_info(path, ext, set)
	if (is.null(file_info)) {
		return(file_info)
	}
	if (!is.null(material)) {
		file_info = filter_file_info(file_info, material=material)
	}
	file_info = read_files(file_info, threads=threads, simple_marker_names=simple_marker_names)
	ret = filter_flowFrame_majority(file_info, threshold)
	file_info = ret$file_info
	selection = ret$selection
	file_info = remove_small_cohorts(file_info, group_size)
	file_info = limit_size(file_info, group_size)
	sel_fun = function(x) { !grepl("LIN", x) }
	trans_fun = flowCore::logTransform(transformationId="log10-transformation", logbase=10, r=1, d=1)
	# disable threading for now, since it requires really a lot of ram
	file_info = transform_ffs(file_info, sel_fun, trans_fun, threads=1)
	return(list(file_info=file_info, selection=selection))
}

transform_ff <- function(ff, sel_fun, trans_fun) {
	markernames = flowCore::colnames(ff)
	trans_markers = markernames[sel_fun(markernames)]
	transform_list = flowCore::transformList(trans_markers, trans_fun)
	ff = flowCore::transform(ff, transform_list)
	return(ff)
}

#' Transform flowcytometric marker channels.
#'
#' Apply a transformation function to the channels specified by the selection function.
#'
#' @param ffs File matrix with loaded flow frames.
#' @param sel_fun Selection function to determine transform application, which returns for an input name either TRUE or FALSE
#' @param trans_fun Transformation function, which will be applied.
#' @param threads Number of cpu threads.
#' @return File Matrix with transformed flow frames.
transform_ffs <- function(ffs, sel_fun, trans_fun, threads=1) {
	flows = parallel::mclapply(ffs[,'fcs'], function(x) { transform_ff(x, sel_fun, trans_fun)}, mc.cores=threads)
	ffs[,'fcs'] = flows
	return(ffs)
}
